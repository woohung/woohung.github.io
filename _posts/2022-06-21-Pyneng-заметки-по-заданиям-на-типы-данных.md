---
layout: post
title: "Pyneng|Заметки по заданиям на типы данных"
date: '2022/06/21|19:00'
categories: [Automation]
tags: [Python]
published: true
author: Artem Kovalchuk
---

<img src="https://woohung.github.io/assets/images/data-types.jpg">

> **Внимание: Если вы уже имеете опыт в Python, эта статья будет для вас бесполезна. Но вы можете поделиться опытом в [телеграм-канале](https://t.me/netautomation), если будет желание.**

Приветствую, друг!  

Это обзор заданий по типам данных, курса Наташи Самойленко - Python для сетевых инженеров.  
Варианты решений есть в одном из репозиторий Наташи, поэтому здесь я не буду раскрывать подробные принципы решения, а только вскольз затрагивать те или иные интересные аспекты заданий.  

> Основное условие курса - все задания должны выполняться теми средствами, которые были пройдены. Т.е нельзя применить в блоке 4 и 5 конструкции `if/elif/else`, например т.к это темы раздела 6.

Я буду приводить текст задания, чтобы было проще понять в каком контексте я описываю те или иные проблемы.  

## Задания в заметке:
<!-- vscode-markdown-toc -->
* [Задание 4.1](#4.1)
* [Задание 4.2](#4.2)
* [Задание 4.3](#4.3)
* [Задание 4.4](#4.4)
* [Задание 4.5](#4.5)
* [Задание 4.6](#4.6)
* [Задание 4.7](#4.7)
* [Задание 4.8](#4.8)

<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->

## <a name='4.1'></a>Задание 4.1
```py
Используя подготовленную строку nat, получить новую строку, в которой в имени интерфейса вместо FastEthernet написано GigabitEthernet.
Полученную новую строку вывести на стандартный поток вывода (stdout) с помощью print.

Ограничение: Все задания надо выполнять используя только пройденные темы.

///

nat = "ip nat inside source list ACL interface FastEthernet0/1 overload"
```
Задание простое, здесь я не встретил никаких проблем, смотрим на тип данных, изучаем как с ним работать, пробуем применять к указанной строке.  

> Совет №1: Сперва изучи главы книги/посмотри лекции.

## <a name='4.2'></a>Задание 4.2
```py
Преобразовать строку в переменной mac из формата XXXX:XXXX:XXXX в формат XXXX.XXXX.XXXX
Полученную новую строку вывести на стандартный поток вывода (stdout) с помощью print.

Ограничение: Все задания надо выполнять используя только пройденные темы.

///

mac = "AAAA:BBBB:CCCC"
```

Аналогично первому заданию, никаких проблем встретить не должны. Помним про методы.

## <a name='4.3'></a>Задание 4.3
```py
Получить из строки config такой список VLANов:
['1', '3', '10', '20', '30', '100']

Записать итоговый список в переменную result.
(именно эта переменная будет проверяться в тесте)

Полученный список result вывести на стандартный поток вывода (stdout)
с помощью print.
Тут очень важный момент, что надо получить именно список (тип данных), а не,
например, строку, которая похожа на показанный список.

Ограничение: Все задания надо выполнять используя только пройденные темы.

///

config = "switchport trunk allowed vlan 1,3,10,20,30,100"
```
В этом задании сложность повышается, нам необходимо выполнить уже несколько действий. Нужно не только обработать указанную строку, но и преобразовать ее к другому типу данных.  
У нас строка, а в ответе требуется список.  

Тактика решения точно такая же, как и в двух предыдущих.  
## <a name='4.4'></a>Задание 4.4
```py
Список vlans это список VLANов, собранных со всех устройств сети,
поэтому в списке есть повторяющиеся номера VLAN.

Из списка vlans нужно получить новый список уникальных номеров VLANов,
отсортированный по возрастанию номеров. Для получения итогового
списка нельзя удалять конкретные vlanы вручную.

Записать итоговый список уникальных номеров VLANов в переменную result.
(именно эта переменная будет проверяться в тесте)

Полученный список result вывести на стандартный поток вывода (stdout)
с помощью print.

Ограничение: Все задания надо выполнять используя только пройденные темы.

///

vlans = [10, 20, 30, 1, 2, 100, 10, 30, 3, 4, 10]

```
Это задание так же из разряда очевидных, само условие подталкивает к использованию определенного типа данных, с которым можно провернуть действие, описанное в условии.  

Так же тут затрагивается сортировка, внимательней присмотритесь к методу, которым будете сортировать список.  

```py
In [52]: list4
Out[52]: [1, 2, 20, 3, 400, 100]

In [53]: print(list4.sort())
None

# Это первое, что я попробовал сделать :)
```

Python (обычно) возвращает `None` из функций и методов, которые изменяют данные, таких как `list.sort` или `list.append` . Т.к Python - объектно-ориентированный язык, то даже "ничто" имеет тип и мы можем проверить. Если воспользоваться функцией `type()`, то выходе мы получаем тип данных `NoneType`  

Еще один вариант увидеть, что тот же метод `sort()` меняет исходный объект, это использовать `id()`  

> ID - возвращает идентификатор указанного объекта. Идентификатор является адресом объекта в памяти.

Попробую пояснить (в первую очередь для себя) за различия "меняет на месте" и "возвращает результат".  

```py
# Имеем два списка, один отсортируем методом sort(), второй с помощью функции sorted и посмотрим их id

In [33]: list3
Out[33]: [1, 10, 2, 200, 30, 300, 5]

In [39]: list4
Out[39]: [1, 2, 20, 3, 400, 100]

# Посмотрим на их текущие id
In [40]: id(list3)
Out[40]: 139747078457792

In [41]: id(list4)
Out[41]: 139747092754240

# Проведем сортировку методом sort() и не увидим Out от Ipython.
In [42]: list3.sort()

# Но если список вызывать отдельно, наш список теперь отсортирован и id у него не изменился.

In [43]: list3
Out[43]: [1, 2, 5, 10, 30, 200, 300]

In [44]: id(list3)
Out[44]: 139747078457792

# Используем функцию sorted(), и видим отсортированный Out. Сразу посмотрим исходный список - он не изменился, id однозначно на это указывает.

In [47]: sorted(list4)
Out[47]: [1, 2, 3, 20, 100, 400]

In [48]: list4
Out[48]: [1, 2, 20, 3, 400, 100]

In [50]: id(list4)
Out[50]: 139747092754240

```

> Совет №2: Изучайте методы.

## <a name='4.5'></a>Задание 4.5
```py
Из строк command1 и command2 получить список VLANов, которые есть
и в команде command1 и в команде command2 (пересечение).

В данном случае, результатом должен быть такой список: ['1', '3', '8']

Записать итоговый список в переменную result. (именно эта переменная будет
проверяться в тесте)

Полученный список result вывести на стандартный поток вывода (stdout) с помощью print.

Ограничение: Все задания надо выполнять используя только пройденные темы.

///

command1 = "switchport trunk allowed vlan 1,2,3,5,8"
command2 = "switchport trunk allowed vlan 1,3,8,9"
```
Здесь прямое развитие предыдущего задания, те же методы, на один из которых предлагается посмотреть подробнее. Ключевое слово тут `пересечение`.  

## <a name='4.6'></a>Задание 4.6
```py
Обработать строку ospf_route и вывести информацию на стандартный поток вывода в виде:
Prefix                10.0.24.0/24
AD/Metric             110/41
Next-Hop              10.0.13.3
Last update           3d18h
Outbound Interface    FastEthernet0/0

Для этого использовать шаблон template и подставить в него значения из строки
ospf_route. Значения из строки ospf_route надо получить с помощью Python.

Ограничение: Все задания надо выполнять используя только пройденные темы.

///

ospf_route = "      10.0.24.0/24 [110/41] via 10.0.13.3, 3d18h, FastEthernet0/0"

template = """
Prefix                {}
AD/Metric             {}
Next-Hop              {}
Last update           {}
Outbound Interface    {}
"""
```

А вот тут уже начинается интересное. Задание выглядит более комплексно, по сравнению с предыдущими.  

Основной проблемой тут для меня было отсутствие понимания "а за что хвататься".  

На самом деле, этот вопрос перед вами встанет только в том случае, если вы так же далеки от программирования, как и я.  

Не стану расписывать подробно ибо лучше, если вы будете подходить к этому сами. Сначала будет больно, непонятно, мысли "тупее вас нет на свете человека" и т.п. Стойко терпите эти унижения от своего подсознания. Окупится.  

> Совет №3: Алгоритмическое мышление - штука, которую придется развивать.

Коротко опишу, что может помочь в решении. Я в любом задании беру за основу условия и входные данные (как в текущем задании переменная `ospf_route`, в которую записана строка с выводом куска таблицы маршрутизации инекий шаблон `template`)  

В шаблон, очевидно, необходимо подставить данные из строки, поэтому сперва работаем с ней.  

Ковыряя любое задание, вы будете запускать свой скрипт раз за разом, чтобы посмотреть вывод и, скорей всего, будете делать это через базовый `print`. Можно пойти по долгому пути и начать пробовать использовать дебагер, либо использовать "дебаг" с помощью `pprint`, вместо `print`, но в конечном итоге, дебагер таки придется освоить :)  

> `pprint` в отличии от `print` в выводе визуально отображает тип данных объекта, что весьма удобно.

После очистки представленной строки для дальнейших действий, можно подумать над тем, как полученные данные "подцепить" в шаблон.  

Вывод (в нашем случае) всегда идет через `print` поэтому и шаблоны придется собирать строковые. Конкретно в этом случае, шаблон уже дан и намекает на конкретный метод.  
В остальных случаях у нас есть вариант либо через f-строки, либо через `format`.  

> Совет №4: Дебаг - ваш будущий друг. Не тяните знакомство с ним.

## <a name='4.7'></a>Задание 4.7
```py
Преобразовать MAC-адрес в строке mac в двоичную строку такого вида:
'101010101010101010111011101110111100110011001100'

Полученную новую строку вывести на стандартный поток вывода (stdout) с помощью print.

Ограничение: Все задания надо выполнять используя только пройденные темы.

///

mac = "AAAA:BBBB:CCCC"
```

Внезапно, задача простая, если предварительно посмотреть еще раз на преобразование типов.  

Сложности могут быть с подбором алгоритма решения. Тут может помочь разбить на октеты, провернуть с ними нужные манипуляции и склеить обратно.  

> Совет №5: Как можно раньше начни использовать f-строки.

## <a name='4.8'></a>Задание 4.8
```py
Преобразовать IP-адрес в переменной ip в двоичный формат и вывести на стандартный
поток вывода вывод столбцами, таким образом:
- первой строкой должны идти десятичные значения байтов
- второй строкой двоичные значения

Вывод должен быть упорядочен также, как в примере:
- столбцами
- ширина столбца 10 символов (в двоичном формате
  надо добавить два пробела между столбцами
  для разделения октетов между собой)

Пример вывода для адреса 10.1.1.1:
10        1         1         1
00001010  00000001  00000001  00000001

Ограничение: Все задания надо выполнять используя только пройденные темы.

///

ip = "192.168.3.1"
```
Задача выглядит сложнее, чем с MAC-адресом, но алгоритм похож.  

Трудностей не вызвало, но были моменты, до которых не сразу дошел. Наприер, можно подглядеть в книге каким способом в f-строках сделать перевод в `bin` с добавлением недостающих 0 до 8 бит. Так же, скорей всего, здесь вы немного застрянете на моменте с выравниваниями (как это вышло у меня), изучите его действие на примерах в книге и затем, например, в ipython.  

Держите в уме, что необходимый вывод столбцами придется собирать построчно.  

> Совет №6: Выделите время на эксперименты (по 30 минут в день самое оно).

<hr>
<p></p>
Это все задачи из раздела по типам данных. В дальнейшем будут такие-же заметки по другим разделам. Сейчас я постигаю раздел 6 и уже есть пара моментов, которые я хотел бы разобрать.  
Обожду недельку, прежде чем продолжать, вдруг подтянутся отзывы на такой формат заметок, чтобы не городить забор без оглядки на заинтересованных.  
<p></p>
<hr>
<h2>Хочешь обсудить тему?</h2>
С вопросами, комментариями и/или замечаниями, приходи в [чат](https://t.me/netautomationarea) или подписывайся на [канал](https://t.me/netautomation).